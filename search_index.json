[
["index.html", "Identifying partners at sea on contrasting fisheries around the world 1 Abstract of the manuscript", " Identifying partners at sea on contrasting fisheries around the world Rocío Joo, Nicolas Bez, Marie-Pierre Etienne, Pablo Marin, Nicolas Goascoz, and Stéphanie Mahévas 2020-09-05 1 Abstract of the manuscript Note: This is the companion website for the manuscript “Identifying partners at sea on contrasting fisheries around the world”, from Joo et al.  Here we present an approach to identify partners at sea based on fishing track analysis, and describe this behaviour in six different fleets: 1) pelagic pair trawlers, 2) large bottom otter trawlers, 3) small bottom otter trawlers, 4) mid-water otter trawlers, all operating in the North-East Atlantic Ocean, 5) anchovy purse-seiners in the South-East Pacific Ocean, and 6) tuna purse-seiners in the Western Indian Ocean. This type of behaviour is known to exist within pelagic pair trawlers. Since these vessels need to be in pairs for their fishing operations, in practice some of them decide to move together throughout their whole fishing trips, and others for only a segment of their trips. To identify partners at sea, we used a heuristic approach based on joint-movement metrics and Gaussian mixture models. The models were first fitted on the pelagic pair trawlers and then used on the other fleets. From all of these fisheries, only the tuna purse-seiners did not present partners at sea. We then analysed the connections at the scale of vessels and identified exclusive partners. This work shows that there are collective tactics at least at a pairwise level in diverse fisheries in the world. "],
["data-processing-and-analysis.html", "2 Data processing and analysis 2.1 Setting up configuration previous to the analysis 2.2 Gaussian mixture modeling 2.3 Classifying the dyads of the other fleets 2.4 Plots and animations of dyad’s tracks and time series, and network graphs", " 2 Data processing and analysis Due to the large volumes of data involved, and confidentiality agreements for the majority of the data, we will share the codes starting when the metrics for the dyads have already been computed. The data shared in this repository are only at the scale of dyads, and not locations. 2.1 Setting up configuration previous to the analysis Calling packages, setting up data, auxiliary code, stats and figure paths, and sourcing functions: knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE) library(lubridate) # date function library(magrittr) # pipes library(stringr) #str_replace_all library(ggplot2) library(xtable) library(maps) # get background library(maptools) # map2SpatialPolygons library(mapdata) # worldHires library(animation) # videos library(igraph) # network representation library(viridis) library(dplyr) # filter, mutate library(Rmixmod) library(FactoMineR) library(tidyr) # gather library(mvtnorm) # for overlap index dossier.data.outputs &lt;- &#39;./DataOutputs/&#39; dossier.stats.outputs &lt;- &#39;./StatsPlots/&#39; dossier.codes &lt;- &#39;./R/&#39; source(paste0(dossier.codes, &#39;dyad_info_general_allgears.r&#39;)) # get summary of dyads source(paste0(dossier.codes, &#39;pre_video_modif_allgears.r&#39;)) # get data into format for video functions source(paste0(dossier.codes, &#39;VideoHtmlDyadAllGears.r&#39;)) # get animation in html source(paste0(dossier.codes, &#39;VideoGIFDyadAllGears.R&#39;)) # get animation in gif source(paste0(dossier.codes, &#39;plot_dyad_general_allgears.R&#39;)) # plot tracks source(paste0(dossier.codes, &#39;subplot_uni.r&#39;)) # plot metric time series source(paste0(dossier.codes, &#39;PlotVideoDyadsGMM.R&#39;)) # general function to plot and animate, using functions above source(paste0(dossier.codes, &#39;FleetStats-AllGears.r&#39;)) # get fleet stats and network graph source(paste0(dossier.codes, &#39;stats_clusters.R&#39;)) # get general statistics of groups source(paste0(dossier.codes, &#39;dyad_classif.R&#39;)) # uses model for pair trawlers to classify the dyads from the other fleets and produce graphs These functions are here. 2.2 Gaussian mixture modeling # load(paste0(dossier.data.outputs, &quot;all_dyads.RData&quot;)) # dyads and metrics dyads &lt;- readRDS(file = paste0(dossier.data.outputs,&quot;all_dyads_vJ.rds&quot;)) # dyads and metrics variables &lt;- c(&quot;Prox&quot;, &quot;DI.theta&quot;, &quot;DI.d&quot;) gear &lt;- &quot;all&quot; # just PTM and variables for analysis dyads %&gt;% filter(gear.1 == &quot;PTM&quot;) %&gt;% select(variables) -&gt; dta ##################### GMM estimation #################################### # specifying some parameters for the GMM parameter estimation strat &lt;- mixmodStrategy(algo = &quot;EM&quot;, initMethod = &quot;smallEM&quot;) # Then GMM with the 3 metrics, for 3 clusters N_rep &lt;- 30 # number of replicates test &lt;- list() for(i in 1:N_rep){ test[[i]] &lt;- Rmixmod::mixmodCluster( data = as.data.frame(dta[, 1:3]), nbCluster = 3, strategy = strat, criterion = c(&quot;ICL&quot;), models = Rmixmod::mixmodGaussianModel( family = &quot;general&quot;, free.proportions = TRUE, equal.proportions = FALSE, listModels = c(&quot;Gaussian_pk_Lk_Ck&quot;) ) ) } # choosing the best model from the replicates based on ICL BestModel &lt;- test[[order(rapply(test, function(x) x@bestResult@criterionValue))[2]]] # saving the best model saveRDS( BestModel, file = paste0( dossier.stats.outputs, &#39;BestFreeModel-PTM-&#39;, gear, &#39;-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;.rds&#39; ) ) ##################### Extracting output stats #################################### # now we are extracting variance values to compare the variance between clusters var_par &lt;- BestModel@bestResult@parameters@variance # var_par is a list with a number of elements equal to the number of clusters, and each element is a variance matrix for the metrics (for a given cluster) # we&#39;ll pay attention to the variances and not covariances, so we&#39;ll use the list to make a matrix where each column is a metric and each row is a cluster, and each element ij is the variance of the metric j in cluster i. variances &lt;- t(sapply(BestModel@bestResult@parameters@variance, function(mat_) { diag(mat_) })) # we then get the minimum variance per metric accross clusters. And, now that I think about it, this is biased by the fact that not all variables are in the same range. DI.theta goes from -1 to 1. minimal_var &lt;- apply(variances, 2, min) # now, how much is variance of each metric in each cluster is higher than the minimum variance of each metric throughout clusters? ratio_var &lt;- sweep(variances, 2, STATS = minimal_var, FUN = &#39;/&#39;) # another form of comparison can be done by using the variances (not covariances) and means to calculate the coefficients of variation cv &lt;- sqrt(t( sapply(BestModel@bestResult@parameters@variance, function(mat_) { diag(mat_) }) )) / BestModel@bestResult@parameters@mean # saving these results cluster.file = paste0( dossier.stats.outputs, &#39;cluster_var_PTM_&#39;, gear, &#39;-&#39;, paste(str_replace_all(variables, &quot;[[:punct:]]&quot;, &quot;&quot;), collapse = &#39;-&#39;), &#39;.txt&#39; ) sink(cluster.file) cat(&quot;Number of clusters: &quot;, BestModel@bestResult@nbCluster, &quot;\\n&quot;) cat(&quot;\\n&quot;) cat(&quot;\\n&quot;) cat(&quot;Metric variances: &quot;, &quot;\\n&quot;) print(variances) cat(&quot;\\n&quot;) cat(&quot;Ratios: &quot;, &quot;\\n&quot;) print(ratio_var) cat(&quot;\\n&quot;) cat(&quot;CV: &quot;, &quot;\\n&quot;) print(cv) cat(&quot;\\n&quot;) cat(&quot;\\n&quot;) sink() # adding the cluster classification and associated probability to the PTM df dta %&gt;% mutate( clust_prox = factor(BestModel@bestResult@partition), p_cluster = apply(BestModel@bestResult@proba, 1, max) ) -&gt; dta # overlapping index mean_variance &lt;- NULL mean_variance$means &lt;- BestModel@bestResult@parameters@mean mean_variance$variance &lt;- BestModel@bestResult@parameters@variance means &lt;- mean_variance$means variances &lt;- mean_variance$variance delta &lt;- 0.025 # pas de discrétisation des lois gaussiennes x &lt;- seq(-1, 2, delta) # discrétisation de l&#39;[] de fluctuation +/- 1 y &lt;- seq(-1, 2, delta) # discrétisation de l&#39;[] de fluctuation +/- 1 z &lt;- seq(-1, 2, delta) # discrétisation de l&#39;[] de fluctuation +/- 1 grid &lt;- expand.grid(x, y, z) gaussian.overlap.trivar &lt;- array(NA, dim = c(3, 3), dimnames = list(c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;), c(&quot;c1&quot;, &quot;c2&quot;, &quot;c3&quot;))) for (i in 1:2) { for (j in (i + 1):3) { #i &lt;- 3 ; j &lt;- 2 p1 &lt;- dmvnorm(x = grid, mean = t(means[i, ]), sigma = variances[[i]]) ### tri-Gaussian for cluster i p2 &lt;- dmvnorm(x = grid, mean = t(means[j, ]), sigma = variances[[j]]) ### tri-Gaussian for cluster j gaussian.overlap.trivar[i, j] &lt;- sum((p1 &lt; p2) * p1 + (p2 &lt; p1) * p2) * delta ^ 3 } } print(&quot;overlapping index&quot;) print(gaussian.overlap.trivar) ##################### Ordering clusters #################################### # Now, we need to find a way to automatically order the clusters by degree of joint movement. # For that, we will use the mean of the scaled and centered variables mean_metrics &lt;- dta %&gt;% mutate( prox_z = scale(Prox, center = TRUE, scale = TRUE), di_theta_z = scale(DI.theta, center = TRUE, scale = TRUE), di_d_z = scale(DI.d, center = TRUE, scale = TRUE) ) %&gt;% group_by(clust_prox) %&gt;% summarise( m_prox_z = mean(prox_z), m_di_theta_z = mean(di_theta_z), m_di_d_z = mean(di_d_z) ) order_clust &lt;- order(apply(mean_metrics[, 2:4], 1, FUN = &quot;mean&quot;), decreasing = TRUE) # once we get the order in which clusters should be, we change the label of clusters so that 1 corresponds to high joint movement... and so on # the clust_prox column was a factor so let&#39;s first transform it into numeric dta$clust_prox &lt;- as.numeric(as.character(dta$clust_prox)) # stock the old label into a vector so that we change things around in this vector new_order_vector &lt;- dta$clust_prox # I could have done this one before: stock the number of clusters in an object k &lt;- length(unique(new_order_vector)) # for each &#39;new label&#39;, we get its corresponding old label, then search in the old column for those observations and change them for the new label in the new vector for (cl in 1:k) { new_order_vector[which(dta$clust_prox == order_clust[cl])] &lt;- cl } # then add a new column to the df with the new order dta$clust_new_order &lt;- new_order_vector # and add a column that is a factor of that dta$group &lt;- as.factor(dta$clust_new_order) ##################### Plots and stats #################################### # Now let&#39;s do some plots with the new order and save them as pdf (for resolution and vectorial graphics) and png (for quick views) # I&#39;m using viridis color palette since it should be colorblind friendly # First plot: first metric vs. second metric dta %&gt;% ggplot(aes(x = dta[, 1], y = dta[, 2], col = group)) + geom_point() + xlab(&#39;Prox&#39;) + ylab(&#39;DItheta&#39;) + scale_colour_viridis_d() + theme_bw() ggsave( paste0( dossier.stats.outputs, &quot;clustFree_Prox_DItheta_PTM_&quot;, gear, &quot;_ordered.pdf&quot; ) ) ggsave( paste0( dossier.stats.outputs, &quot;clustFree_Prox_DItheta_PTM_&quot;, gear, &quot;_ordered.png&quot; ) ) # First metric vs. third metric dta %&gt;% ggplot(aes(x = dta[, 1], y = dta[, 3], col = group)) + geom_point() + xlab(&#39;Prox&#39;) + ylab(&#39;DId&#39;) + scale_colour_viridis_d() + theme_bw() ggsave(paste0( dossier.stats.outputs, &quot;clustFree_Prox_DId_PTM_&quot;, gear, &quot;_ordered.pdf&quot; )) ggsave(paste0( dossier.stats.outputs, &quot;clustFree_Prox_DId_PTM_&quot;, gear, &quot;_ordered.png&quot; )) # Now plotting distributions of probabilities per cluster # median posterior probability per cluster dta %&gt;% group_by(group) %&gt;% summarise(median(p_cluster)) ggplot(data = dta, aes (x = group, y = p_cluster, fill = group)) + geom_boxplot() + scale_fill_viridis(discrete = TRUE) + theme_bw() + xlab(&#39;&#39;) + ylab(&quot;&quot;) + theme(legend.position = &quot;none&quot;, text = element_text(size = 18)) ggsave(paste0( dossier.stats.outputs, &quot;clustFree_proba_PTM_&quot;, gear, &quot;_ordered.pdf&quot; )) ggsave(paste0( dossier.stats.outputs, &quot;clustFree_proba_PTM_&quot;, gear, &quot;_ordered.png&quot; )) # calculating the percentage of PTM dyads in each cluster and then saving the information perc_table &lt;- round(prop.table(table(dta$group)) * 100, 1) sink(cluster.file, append = TRUE) cat(&quot;Order of old labels: &quot;, &quot;\\n&quot;) print(order_clust) cat(&quot;\\n&quot;) cat(&quot;\\n&quot;) cat(&quot;Percentage of dyads in each ordered cluster: &quot;, &quot;\\n&quot;) print(perc_table) cat(&quot;\\n&quot;) cat(&quot;\\n&quot;) sink() # Now I want to know what the distribution of each metric looks like in each cluster. I&#39;ll do that through violin plots. For that, I&#39;ll need to work on the format of the df to plot # Selecting just the columns of interest dta_facto &lt;- dta[, c(1, 2, 3, 4, 7)] # Gathering into more rows and less columns dta_gather &lt;- dta_facto %&gt;% gather(key = metric, value = value,-clust_prox,-group) # Transforming the new metric column into a factor with levels ordered based on the contribution of each metric to the first principal component dta_gather$metric &lt;- factor(dta_gather$metric, levels = c(&quot;Prox&quot;, &quot;DI.theta&quot;, &quot;DI.d&quot;)) #names(weight_var)[order(weight_var, # decreasing = TRUE)]) # histograms ggplot(data = dta_gather, aes(x = value, color = group)) + geom_histogram(fill = &quot;white&quot;, position = &quot;dodge&quot;) + # geom_density(alpha=0.6)+ facet_wrap(facets = vars(metric), scales = &quot;free&quot;) + scale_color_viridis(discrete = TRUE) + theme_bw() + xlab(&#39;&#39;) + ylab(&quot;&quot;) + theme(legend.position = &quot;none&quot;, text = element_text(size = 16)) ggsave( paste0( dossier.stats.outputs, &quot;clustFree_MetricsHist_PTM_&quot;, gear, &quot;_ordered.pdf&quot; ), width = 8 ) ggsave( paste0( dossier.stats.outputs, &quot;clustFree_MetricsHist_PTM_&quot;, gear, &quot;_ordered.png&quot; ), width = 8 ) ## Here we&#39;ll be computing stats about the number of dyads, couples, vessels, etc., in total and each cluster # First, we&#39;ll save a df with everything we could care about for PTM dyads dyads_cluster &lt;- dyads %&gt;% filter(gear.1 == &quot;PTM&quot;) dyads_cluster &lt;- cbind.data.frame(dyads_cluster, dta[, c(&quot;p_cluster&quot;, &quot;clust_new_order&quot;)]) saveRDS( dyads_cluster, file = paste0( dossier.data.outputs, &#39;ClustPCAoutputs-PTM-&#39;, gear, &#39;-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;_ordered.rds&#39; ) ) # now we compute the stats and save them in .RData and a LaTeX table format stats.clusters &lt;- stats_clusters(k, dyads_cluster) save( stats.clusters, file = paste0( dossier.data.outputs, &quot;ClusterTable-&quot;, k, &#39;-PTM-&#39;, gear, &#39;-&#39;, paste(variables, collapse = &#39;-&#39;), &#39;ordered.RData&#39; ) ) print( xtable(t(stats.clusters)), file = paste0( dossier.stats.outputs, &quot;ClusterLatexTable-&quot;, k, &#39;-PTM-&#39;, gear, &#39;-&#39;, paste(variables, collapse = &#39;-&#39;), &#39;ordered.txt&#39; ) ) 2.3 Classifying the dyads of the other fleets We use the Best GMM for pelagic pair trawlers to classify the other dyads into the 3 groups, by fleet. We also do the same graphs as for the pair trawlers (and some extras) and produce the statistics by cluster. We use functions called above. # Large bottom otter trawlers dyad_classif( gear = &quot;LOTB&quot;, variables, dyads, BestModel, k, order_clust, cluster.file, dossier.stats.outputs, dossier.data.outputs, dta ) # Small bottom otter trawlers dyad_classif( gear = &quot;SOTB&quot;, variables, dyads, BestModel, k, order_clust, cluster.file, dossier.stats.outputs, dossier.data.outputs, dta ) # Mid-water otter trawlers dyad_classif( gear = &quot;OTM&quot;, variables, dyads, BestModel, k, order_clust, cluster.file, dossier.stats.outputs, dossier.data.outputs, dta ) # Tuna purse-seiners dyad_classif( gear = &quot;thon&quot;, variables, dyads, BestModel, k, order_clust, cluster.file, dossier.stats.outputs, dossier.data.outputs, dta ) # Anchovy purse-seiners dyad_classif( gear = &quot;APS-10&quot;, variables, dyads, BestModel, k, order_clust, cluster.file, dossier.stats.outputs, dossier.data.outputs, dta ) 2.4 Plots and animations of dyad’s tracks and time series, and network graphs In order to reproduce this code, you would need the actual VMS data from the fleets, which I cannot provide. Due to the same confidentiality issues, these plots are anonymous, without coastlines and the longitude and latitude coordinates are transformed. # We first set some values for parameters video.par &lt;- NULL video.par$type &lt;- &#39;plot&#39; # choose between video, plot, series and all video.par$mp4 &lt;- FALSE # IF SO, ffmpeg function must be able to run in the konsole video.par$gif &lt;- FALSE # Or TRUE video.par$html &lt;- FALSE # we need this to be TRUE to create mp4 anyway video.par$series_gif &lt;- FALSE # Or TRUE. To produce gifs of time series of the metrics video.par$series_pdf &lt;- FALSE # Or TRUE. To produce pdf graphs of time series of the metrics video.par$traza = 10 # number of hours for leaving a trace at each frame in the video video.par$epais = 4 # width of trajectories video.par$sleep = 0.25 # time between frames (quarter of a second) video.par$point.size = 1.2 # size of points in the plots and animations # VMS data load(paste0(dossier.data.outputs,&#39;DATA_TRAJECTORIES_YEAR_2012_GAP_3H.rdata&#39;)) vms_data_2012 &lt;- data.trajectories$DATA.TRAJECTORIES load(paste0(dossier.data.outputs,&#39;DATA_TRAJECTORIES_YEAR_2013_GAP_3H.rdata&#39;)) vms_data_2013 &lt;- data.trajectories$DATA.TRAJECTORIES vms_trawlers &lt;- rbind.data.frame(vms_data_2012, vms_data_2013) old_names &lt;- colnames(vms_trawlers) colnames(vms_trawlers) &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, old_names[4:8], &quot;abs.angle&quot;, old_names[10], &quot;id&quot;, &quot;burst&quot;, old_names[13:30], &quot;gear.maree&quot;, old_names[32], &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &#39;line&#39;, old_names[36:38]) rm(vms_data_2012, vms_data_2013, data.trajectories) load(paste0(dossier.data.outputs, &#39;vms_thon_2011-2013.RData&#39;)) vms_thon &lt;- vms.data.years load(paste0(dossier.data.outputs, &quot;vms_data_10.RData&quot;)) vms_aps &lt;- vms.data # For pelagic pair trawlers vms_ptm &lt;- vms_trawlers[which(as.character(vms_trawlers$gear.maree) == &quot;PTM&quot;), ] dyads_ptm &lt;- readRDS(file = paste0( dossier.data.outputs, &#39;ClustPCAoutputs-PTM-all-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;_ordered.rds&#39; )) columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;line&quot;) vms.data &lt;- vms_ptm[, columns] Prox_delta &lt;- c(1, 3, 5) DI_beta &lt;- 1 plots.video.dyads.allgears( vms.data, dyads = dyads_ptm, n = 1, gear = &quot;PTM&quot;, new.variables = variables, dossier.data.outputs, dossier.stats.outputs, text.dyads = TRUE, video.par, colores = c(&quot;#66c2a5&quot;, &quot;#fc8d62&quot;, &quot;#8da0cb&quot;) ) Fleet.Analysis( vms.data, dyads = dyads_ptm, dossier.data.outputs, dossier.stats.outputs, gear = &quot;PTM&quot; ) # For larger bottom otter trawlers vms_lotb &lt;- vms_trawlers[which(as.character(vms_trawlers$gear.maree) == &quot;OTB&quot;), ] dyads_lotb &lt;- readRDS(file = paste0( dossier.data.outputs, &#39;ClustPCAoutputs-PTM-LOTB-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;_ordered.rds&#39; )) columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;line&quot;) vms.data &lt;- vms_lotb[, columns] Prox_delta &lt;- c(1, 3, 5) DI_beta &lt;- 1 plots.video.dyads.allgears( vms.data, dyads = dyads_lotb, n = 1, gear = &quot;LOTB&quot;, new.variables = variables, dossier.data.outputs, dossier.stats.outputs, text.dyads = TRUE, video.par, colores = c(&quot;#66c2a5&quot;, &quot;#fc8d62&quot;, &quot;#8da0cb&quot;) ) Fleet.Analysis( vms.data, dyads = dyads_lotb, dossier.data.outputs, dossier.stats.outputs, gear = &quot;LOTB&quot; ) # For small bottom otter trawlers vms_sotb &lt;- vms_trawlers[which(as.character(vms_trawlers$gear.maree) == &quot;OTB_SMALL&quot;), ] dyads_sotb &lt;- readRDS(file = paste0( dossier.data.outputs, &#39;ClustPCAoutputs-PTM-SOTB-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;_ordered.rds&#39; )) columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;line&quot;) vms.data &lt;- vms_sotb[, columns] Prox_delta &lt;- c(1, 3, 5) DI_beta &lt;- 1 plots.video.dyads.allgears( vms.data, dyads = dyads_sotb, n = 1, gear = &quot;SOTB&quot;, new.variables = variables, dossier.data.outputs, dossier.stats.outputs, text.dyads = TRUE, video.par, colores = c(&quot;#66c2a5&quot;, &quot;#fc8d62&quot;, &quot;#8da0cb&quot;) ) Fleet.Analysis( vms.data, dyads = dyads_sotb, dossier.data.outputs, dossier.stats.outputs, gear = &quot;SOTB&quot; ) # For mid-water otter trawlers vms_otm &lt;- vms_trawlers[which(as.character(vms_trawlers$gear.maree) == &quot;OTM&quot;), ] dyads_otm &lt;- readRDS(file = paste0( dossier.data.outputs, &#39;ClustPCAoutputs-PTM-OTM-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;_ordered.rds&#39; )) columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;line&quot;) vms.data &lt;- vms_otm[, columns] Prox_delta &lt;- c(1, 3, 5) DI_beta &lt;- 1 plots.video.dyads.allgears( vms.data, dyads = dyads_otm, n = 1, gear = &quot;OTM&quot;, new.variables = variables, dossier.data.outputs, dossier.stats.outputs, text.dyads = TRUE, video.par, colores = c(&quot;#66c2a5&quot;, &quot;#fc8d62&quot;, &quot;#8da0cb&quot;) ) Fleet.Analysis( vms.data, dyads = dyads_otm, dossier.data.outputs, dossier.stats.outputs, gear = &quot;OTM&quot; ) # For tuna purse-seiners dyads_tps &lt;- readRDS(file = paste0( dossier.data.outputs, &#39;ClustPCAoutputs-PTM-thon-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;_ordered.rds&#39; )) columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;lignes&quot;) vms.data &lt;- vms_thon[, columns] names(vms.data) &lt;- columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;line&quot;) Prox_delta &lt;- c(10, 30, 60) DI_beta &lt;- 1 plots.video.dyads.allgears( vms.data, dyads = dyads_tps, n = 1, gear = &quot;TPS&quot;, new.variables = variables, dossier.data.outputs, dossier.stats.outputs, text.dyads = TRUE, video.par, colores = c(&quot;#66c2a5&quot;, &quot;#fc8d62&quot;, &quot;#8da0cb&quot;) ) # Since there are no dyads in group 1, there is no network analysis for this fleet. # For anchovy purse-seiners dyads_aps &lt;- readRDS( file = paste0( dossier.data.outputs, &#39;ClustPCAoutputs-PTM-APS-10-&#39;, paste0(variables, collapse = &#39;-&#39;), &#39;_ordered.rds&#39; ) ) columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;ligne&quot;) vms.data &lt;- vms_aps[, columns] names(vms.data) &lt;- columns &lt;- c(&quot;x&quot;, &quot;y&quot;, &quot;date&quot;, &quot;id&quot;, &quot;burst&quot;, &quot;abs.angle&quot;, &quot;LONGITUDE&quot;, &quot;LATITUDE&quot;, &quot;line&quot;) Prox_delta &lt;- c(1, 3, 5) DI_beta &lt;- 1 plots.video.dyads.allgears( vms.data, dyads = dyads_aps, n = 1, gear = &quot;APS&quot;, new.variables = variables, dossier.data.outputs, dossier.stats.outputs, text.dyads = TRUE, video.par, colores = c(&quot;#66c2a5&quot;, &quot;#fc8d62&quot;, &quot;#8da0cb&quot;) ) Fleet.Analysis( vms.data, dyads = dyads_aps, dossier.data.outputs, dossier.stats.outputs, gear = &quot;APS&quot; ) "],
["supplementary-results.html", "3 Supplementary results 3.1 Pelagic pair trawlers 3.2 Large bottom otter trawlers 3.3 Small bottom otter trawlers 3.4 Mid-water otter trawlers 3.5 Anchovy purse-seiners 3.6 Tuna purse-seiners", " 3 Supplementary results For each fleet, the most representative dyad in each group is shown through a spatial representation (the locations have been transformed to respect confidentiality agreements with some of the data providers) and time series of distance (in km), DItheta and DId. The numbers in parenthesis in the distance graphs indicate values of Prox with \\(\\delta\\) equal to 1, 3 or 5. 3.1 Pelagic pair trawlers Histogram for each group per metric. 3.1.1 Group 1: most representative example 3.1.2 Group 2: most representative example 3.1.3 Group 3: most representative example 3.2 Large bottom otter trawlers Histogram for each group per metric. 3.2.1 Group 1: most representative example 3.2.2 Group 2: most representative example 3.2.3 Group 3: most representative example 3.3 Small bottom otter trawlers Histogram for each group per metric. 3.3.1 Group 1: most representative example 3.3.2 Group 2: most representative example 3.3.3 Group 3: most representative example 3.4 Mid-water otter trawlers Histogram for each group per metric. 3.4.1 Group 1: most representative example 3.4.2 Group 2: most representative example 3.4.3 Group 3: most representative example 3.5 Anchovy purse-seiners Histogram for each group per metric. 3.5.1 Group 1: most representative example 3.5.2 Group 2: most representative example 3.5.3 Group 3: most representative example 3.6 Tuna purse-seiners Histogram for each group per metric. Purple and yellow are groups 2 and 3, respectively. 3.6.1 Group 2: most representative example 3.6.2 Group 3: most representative example "],
["r-session-information.html", "4 R Session Information", " 4 R Session Information devtools::session_info() ## ─ Session info ─────────────────────────────────────────────────────────────── ## setting value ## version R version 3.6.3 (2020-02-29) ## os Ubuntu 18.04.5 LTS ## system x86_64, linux-gnu ## ui X11 ## language (EN) ## collate en_US.UTF-8 ## ctype en_US.UTF-8 ## tz America/Nassau ## date 2020-09-05 ## ## ─ Packages ─────────────────────────────────────────────────────────────────── ## package * version date lib source ## animation * 2.6 2018-12-11 [1] CRAN (R 3.6.1) ## assertthat 0.2.1 2019-03-21 [1] CRAN (R 3.6.1) ## backports 1.1.8 2020-06-17 [1] CRAN (R 3.6.3) ## bookdown 0.16 2019-11-22 [1] CRAN (R 3.6.1) ## callr 3.4.3 2020-03-28 [1] CRAN (R 3.6.3) ## cli 2.0.2 2020-02-28 [1] CRAN (R 3.6.3) ## cluster 2.1.0 2019-06-19 [1] CRAN (R 3.6.3) ## colorspace 1.4-1 2019-03-18 [1] CRAN (R 3.6.1) ## crayon 1.3.4 2017-09-16 [1] CRAN (R 3.6.1) ## desc 1.2.0 2018-05-01 [1] CRAN (R 3.6.1) ## devtools 2.2.1 2019-09-24 [1] CRAN (R 3.6.1) ## digest 0.6.25 2020-02-23 [1] CRAN (R 3.6.3) ## dplyr * 1.0.0 2020-05-29 [1] CRAN (R 3.6.3) ## ellipsis 0.3.1 2020-05-15 [1] CRAN (R 3.6.3) ## evaluate 0.14 2019-05-28 [1] CRAN (R 3.6.1) ## FactoMineR * 2.0 2019-11-25 [1] CRAN (R 3.6.1) ## fansi 0.4.1 2020-01-08 [1] CRAN (R 3.6.3) ## flashClust 1.01-2 2012-08-21 [1] CRAN (R 3.6.1) ## foreign 0.8-76 2020-03-03 [4] CRAN (R 3.6.3) ## fs 1.3.1 2019-05-06 [1] CRAN (R 3.6.1) ## generics 0.0.2 2018-11-29 [1] CRAN (R 3.6.1) ## ggplot2 * 3.3.2 2020-06-19 [1] CRAN (R 3.6.3) ## ggrepel 0.8.1 2019-05-07 [1] CRAN (R 3.6.1) ## glue 1.4.1 2020-05-13 [1] CRAN (R 3.6.3) ## gridExtra 2.3 2017-09-09 [1] CRAN (R 3.6.1) ## gtable 0.3.0 2019-03-25 [1] CRAN (R 3.6.1) ## htmltools 0.4.0 2019-10-04 [1] CRAN (R 3.6.1) ## igraph * 1.2.5 2020-03-19 [1] CRAN (R 3.6.3) ## knitr * 1.28 2020-02-06 [1] CRAN (R 3.6.3) ## lattice 0.20-41 2020-04-02 [4] CRAN (R 3.6.3) ## leaps 3.0 2017-01-10 [1] CRAN (R 3.6.1) ## lifecycle 0.2.0 2020-03-06 [1] CRAN (R 3.6.3) ## lubridate * 1.7.4 2018-04-11 [1] CRAN (R 3.6.1) ## magrittr * 1.5 2014-11-22 [1] CRAN (R 3.6.1) ## mapdata * 2.3.0 2018-03-30 [1] CRAN (R 3.6.1) ## maps * 3.3.0 2018-04-03 [1] CRAN (R 3.6.1) ## maptools * 0.9-8 2019-10-05 [1] CRAN (R 3.6.1) ## MASS 7.3-51.6 2020-04-26 [4] CRAN (R 3.6.3) ## memoise 1.1.0 2017-04-21 [1] CRAN (R 3.6.1) ## munsell 0.5.0 2018-06-12 [1] CRAN (R 3.6.1) ## mvtnorm * 1.1-1 2020-06-09 [1] CRAN (R 3.6.3) ## pillar 1.4.4 2020-05-05 [1] CRAN (R 3.6.3) ## pkgbuild 1.0.8 2020-05-07 [1] CRAN (R 3.6.3) ## pkgconfig 2.0.3 2019-09-22 [1] CRAN (R 3.6.1) ## pkgload 1.1.0 2020-05-29 [1] CRAN (R 3.6.3) ## prettyunits 1.1.1 2020-01-24 [1] CRAN (R 3.6.3) ## processx 3.4.2 2020-02-09 [1] CRAN (R 3.6.3) ## ps 1.3.3 2020-05-08 [1] CRAN (R 3.6.3) ## purrr 0.3.4 2020-04-17 [1] CRAN (R 3.6.3) ## R6 2.4.1 2019-11-12 [1] CRAN (R 3.6.1) ## Rcpp * 1.0.4.6 2020-04-09 [1] CRAN (R 3.6.3) ## remotes 2.1.0 2019-06-24 [1] CRAN (R 3.6.1) ## rlang 0.4.7 2020-07-09 [1] CRAN (R 3.6.3) ## rmarkdown 2.1 2020-01-20 [1] CRAN (R 3.6.3) ## Rmixmod * 2.1.2.2 2019-03-11 [1] CRAN (R 3.6.1) ## rprojroot 1.3-2 2018-01-03 [1] CRAN (R 3.6.1) ## rstudioapi 0.11 2020-02-07 [1] CRAN (R 3.6.3) ## scales 1.1.1 2020-05-11 [1] CRAN (R 3.6.3) ## scatterplot3d 0.3-41 2018-03-14 [1] CRAN (R 3.6.1) ## sessioninfo 1.1.1 2018-11-05 [1] CRAN (R 3.6.1) ## sp * 1.4-2 2020-05-20 [1] CRAN (R 3.6.3) ## stringi 1.4.6 2020-02-17 [1] CRAN (R 3.6.3) ## stringr * 1.4.0 2019-02-10 [1] CRAN (R 3.6.1) ## testthat 2.3.2 2020-03-02 [1] CRAN (R 3.6.3) ## tibble 3.0.1 2020-04-20 [1] CRAN (R 3.6.3) ## tidyr * 1.1.0 2020-05-20 [1] CRAN (R 3.6.3) ## tidyselect 1.1.0 2020-05-11 [1] CRAN (R 3.6.3) ## usethis 1.5.1 2019-07-04 [1] CRAN (R 3.6.1) ## vctrs 0.3.1 2020-06-05 [1] CRAN (R 3.6.3) ## viridis * 0.5.1 2018-03-29 [1] CRAN (R 3.6.1) ## viridisLite * 0.3.0 2018-02-01 [1] CRAN (R 3.6.1) ## withr 2.2.0 2020-04-20 [1] CRAN (R 3.6.3) ## xfun 0.14 2020-05-20 [1] CRAN (R 3.6.3) ## xtable * 1.8-4 2019-04-21 [1] CRAN (R 3.6.1) ## yaml 2.2.1 2020-02-01 [1] CRAN (R 3.6.3) ## ## [1] /home/rjoo/R/x86_64-pc-linux-gnu-library/3.6 ## [2] /usr/local/lib/R/site-library ## [3] /usr/lib/R/site-library ## [4] /usr/lib/R/library "]
]
